----------constants module-----------

#Area types

AREA_TYPE_DEFORESTED = "Deforested"
AREA_TYPE_VUN = "Vunerable"
AREA_TYPE_REFORESTED = "Reforested"

#Deforestation Types

DEF_TYPE_DEFORESTATION = "Deforetation"
DEF_TYPE_FORESTDEGRADATION = "Forest Degradation"
DEF_TYPE_FORESTFRAGMENTATION = "Forest Fragmentation"

#Area Outline Fill
DEF_COLOUR = "red"
VUN_COLOUR = "yellow"
REF_COLOUR = "green"

#Area Pattern fill
DEFF_COLOUR = "red"
FRAG_COLOUR = "black"
DEG_COLOUR = "white"



------------deforestMain---------

#importing system modules to access the command line and operating system
import sys
import os
import os.path, shutil
import glob

#importing PyQgis and PyQt libraries
from qgis.gui import *
from qgis.core import *
from PyQt4.QtCore import *
from PyQt4.QtGui import *
from osgeo import gdal

#the GUI template
from ui_mainWindow import Ui_MainWindow

#importing the resources module
import resources
from constants import *
from mapTools import *
from dialogTools import *

#pyqt based application use multiply inheritance to include the ui template as a parent of the Deforestation application
#set up class for the main window. Inherits the object from PyQT Main Window and ui_mainWindow class

class DeforestationMapWindow(QMainWindow, Ui_MainWindow):
    #initialising, (basically a constructer) Whenever this class is called this method will.
    def __init__(self):
        QMainWindow.__init__(self) #initialising the inherited object, no need to inherit from the super class as importing the whole module
        self.setupUi(self) #initialising the setUPUI method from ui_mainWindow, and passing parent class to have access to window
   
        #connecting the action buttons to to the respective reference method when clicked
        self.connect(self.actionZoomIn, SIGNAL("triggered()"), self.zoomIn)
        self.connect(self.actionZoomOut, SIGNAL("triggered()"), self.zoomOut)
        self.connect(self.actionPanMode, SIGNAL("triggered()"), self.panMode)
        self.connect(self.actionEditMode, SIGNAL("triggered()"), self.setEditMode)
        self.connect(self.actionAddArea, SIGNAL("triggered()"), self.addArea)
        self.connect(self.actionEditArea, SIGNAL("triggered()"), self.editArea)
        self.connect(self.actionRemoveArea, SIGNAL("triggered()"), self.removeArea)
        self.connect(self.actionGetAreaInfo, SIGNAL("triggered()"), self.getAreaInfo)
        self.connect(self.actionAddLayer, SIGNAL("triggered()"), self.addLayer)
        self.connect(self.actionRemoveLayer, SIGNAL("triggered()"), self.removeLayer)
        self.connect(self.actionMapInfo, SIGNAL("triggered()"), self.getMapInfo)
        self.connect(self.actionPrint, SIGNAL("triggered()"), self.onPrint)
        
        #connecting a specfic method of the combo box, calling onSelectionChange method when the index of the mapCombo box has changed
        self.mapComboBox.currentIndexChanged.connect(self.onSelectionChange)
        
        #setting current directory
        self.cur_dir = os.path.dirname(os.path.realpath(__file__))
        
        #setting path of geoData directory in the cur_dir
        self.map_layers = os.path.join(self.cur_dir, "geoData")
        
        #creating list to store the current maps for use the the onPrint method
        self.layer_set = []
        
        #creating an instance of Qgs Map canvas and bringing to front
        self.mapCanvas = QgsMapCanvas()
        self.mapCanvas.useImageToRender(False)
        self.mapCanvas.setCanvasColor(Qt.white)
        self.mapCanvas.show()
        
        #setting the layout and adding the canvas
        layout = QVBoxLayout()
        layout.setContentsMargins(0, 0, 0, 0)
        layout.addWidget(self.mapCanvas)
        self.centralWidget.setLayout(layout)
    
        #bool variables for editing mode and vector data is modified
        self.editing  = False
        self.modified = False
    
#adjust the button's states
    def setButtonsStatus(self):
        if len(self.maps) > 0:
            self.actionEditMode.setEnabled(True)
            self.actionAddLayer.setChecked(False)
            self.actionRemoveLayer.setChecked(False)
            self.actionMapInfo.setChecked(False)
            self.actionPanMode.setEnabled(True)
            if self.editing:
                self.actionAddArea.setEnabled(True)
                self.actionRemoveArea.setEnabled(True)
                self.actionEditArea.setEnabled(True)
                self.actionGetAreaInfo.setEnabled(True)
                self.actionRemoveLayer.setEnabled(False)
                self.actionAddLayer.setEnabled(False)
                self.mapComboBox.setEnabled(False)
                self.actionMapInfo.setEnabled(False)
            else:
                self.actionAddArea.setEnabled(False)
                self.actionRemoveArea.setEnabled(False)
                self.actionEditArea.setEnabled(False)
                self.actionGetAreaInfo.setEnabled(False)
                self.actionZoomIn.setEnabled(True)
                self.actionZoomOut.setEnabled(True)
                self.actionRemoveLayer.setEnabled(True)
                self.actionAddLayer.setEnabled(True)
                self.actionMapInfo.setEnabled(True)
                self.mapComboBox.setEnabled(True)
        else:
            self.actionAddArea.setEnabled(False)
            self.actionRemoveArea.setEnabled(False)
            self.actionGetAreaInfo.setEnabled(False)
            self.actionEditMode.setEnabled(False)
            self.actionZoomIn.setEnabled(False)
            self.actionZoomOut.setEnabled(False)
            self.actionPanMode.setEnabled(False)
            self.actionRemoveLayer.setEnabled(False)
            self.actionMapInfo.setEnabled(False)
            self.mapComboBox.setEnabled(False)
    
#button event handlers
    #setting to the default map canvas zoom in/out method
    def zoomIn(self):
        self.mapCanvas.zoomIn()

    def zoomOut(self):
        self.mapCanvas.zoomOut()
    
    #setting to panTool instanstiated in set up map
    def panMode(self):
        self.mapCanvas.setMapTool(self.panTool)
    
    #edit mode button method for saving changes to the vector layer database
    def setEditMode(self):
        #if user in editing mode check if data been modified and prompt to save
        if self.editing:
            if self.modified:
                reply = QMessageBox.question(self, "Confirm", "Save Changes?", QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)
                if reply == QMessageBox.Yes:
                    #save changes
                     self.deforestObjectLayer.commitChanges()
                else:
                    #discard changes
                     self.deforestObjectLayer.rollBack()
            else:
                self.deforestObjectLayer.commitChanges()
            
            #forces update on of the map canvas
            self.deforestObjectLayer.triggerRepaint()
            self.editing = False
            self.panMode()
        else:
            
            #vector layer set to editing, force a update of the vector layer.
            self.deforestObjectLayer.startEditing()
            self.deforestObjectLayer.triggerRepaint()
            self.editing  = True
            self.modified = False
                                                                     
        self.setButtonsStatus()

#set the mapCanvas map tool to the custom map tools when user clicks on the repective button: add, edit, remove, getAreaInfo. making sure the respespective connected button is checked
    def addArea(self):
        if self.actionAddArea.isChecked():
            self.mapCanvas.setMapTool(self.addDeforestObject)
        else:
            self.panMode()
        self.setButtonsStatus()

    def editArea(self):
        if self.actionEditArea.isChecked():
            self.mapCanvas.setMapTool(self.editDeforestObject)
        else:
            self.panMode()
        self.setButtonsStatus()
    
    def removeArea(self):
        if self.actionRemoveArea.isChecked():
            self.mapCanvas.setMapTool(self.removeDeforestObject)
        else:
            self.panMode()
        self.setButtonsStatus()
            
    def getAreaInfo(self):
        if self.actionGetAreaInfo.isChecked():
            self.mapCanvas.setMapTool(self.getAreaInfoTool)
        else:
            self.panMode()

    def getMapInfo(self):
        mapDialog = MapDialog(self, self.deforestObjectLayer)
        if mapDialog.exec_():
            self.mapCanvas.refresh()
            self.setButtonsStatus()

#Adding .tif file
    def addLayer(self):
        if self.actionAddLayer.isChecked():
            #use of the the QFileDialog object to retrieve map
            filePath = QFileDialog.getOpenFileName(self, "." , "Image Files (*.tif)")
            
            #QFileInfo object to get the name of the file without the type
            fileInfo = QFileInfo(filePath)
            
            #check whether user collection is a tif file
            if ".tif" in filePath:
                currentMapName = fileInfo.baseName()
                
                #storing path .tif files to validate if they exits
                mapPathVal = os.path.join(self.cur_dir, "geoData", currentMapName + ".tif")
                
                mapPathVal1 = os.path.join(self.cur_dir, "geoData", currentMapName + "WGS84" + ".tif")
                
                #check if user added file exits
                if not os.path.exists(mapPathVal) | os.path.exists(mapPathVal1):
                    currentMapName = fileInfo.baseName()
                    ReprojectGeospatialFile().reprojectTifFile(mapPathVal1, filePath, self.onAddedLayer)
            
                else:
                    QMessageBox.about(self, "Map Already Exists", "Fix: %s" % "Rename" )
        
            #Stating to user what file type is need.
            elif len(filePath) < 3 | len(filePath) > 3:
                QMessageBox.about(self, "Error", "Fix: %s" % "Geo referenced .tif "  )

#remove layers from the application when the actionRemoveLayer is selected
    def removeLayer(self):
        #Throw message box to confirm the users selection of removing the map
        reply = QMessageBox.question(self, "Confirm", "Delete Layer?", QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)
        
        #clear map registry and remove the respective map form the geoData library
        if reply == QMessageBox.Yes:
            
            QgsMapLayerRegistry.instance().removeAllMapLayers()
            
            mapLayerPath = self.maps[self.mapComboBox.currentIndex()]
            mapName = os.path.splitext(os.path.basename(mapLayerPath))[0]
            
            #remove map layers from the current lay_set
            del self.layer_set[:]
            
            os.remove(mapLayerPath)
            os.remove(self.map_layers + "/" + mapName + ".sqlite")
            
            #up date the map comboBox and canvas of change
            self.setUpMapsComboBox()
            self.mapCanvas.refresh()
        
        self.setButtonsStatus()

#Change map to selected from the combo box
    def onSelectionChange(self):
        if len(self.maps) > 0:
            #retrieve the new map
            mapLayerPath = self.maps[self.mapComboBox.currentIndex()]
            mapName = os.path.splitext(os.path.basename(mapLayerPath))[0]
            
            #remove old layers from the map registry
            QgsMapLayerRegistry.instance().removeAllMapLayers()
            del self.layer_set[:]
            
            #set up and diasplay the layers
            self.setMapLayers(mapLayerPath, mapName)
            self.setVectorRenderer()
            self.setMapTools()
            self.mapCanvas.refresh()
    
###########completion of the map tools functions############

    def onGetAreaInfo(self, feature):
        #instatiating getAreaInforDialog to display feature
        dialog = getAreaInfoDialog(self, feature)
        dialog.loadAttributes(feature)
        if dialog.exec_():
            dialog.saveAttributes(feature)
            self.deforestObjectLayer.updateFeature(feature)
            self.modified = True
            self.mapCanvas.refresh()

    #call back funtion from AddedDeforestation MapTool.
    def onDeforestObjectAdded(self):
        self.modified = True
        self.mapCanvas.refresh()
        self.actionAddArea.setChecked(False)
        self.panMode()

    #call back function from RemoveDeforestOject MapTool
    def onDeforestObjectRemoved(self):
        self.modified = True
        self.mapCanvas.refresh()
        self.actionRemoveArea.setChecked(False)
        self.panMode()

    #call back function from the EditDeforestObject MapTool
    def onDeforestObjectEdited(self):
        self.modified = True
        self.mapCanvas.refresh()
    
    #call back function from the convertToTiff function
    def onAddedLayer(self, rasterLayer):
        #checking if reprojection failed
        vectorLayer = os.path.splitext(os.path.basename(rasterLayer))[0]
        if rasterLayer is not None:
            #set up new layer
            self.maps.append(rasterLayer)
            self.setUpDatabase(vectorLayer)
            self.setUpMapsComboBox()
            self.setButtonsStatus()
        else:
            QMessageBox.about(self, "Error", "Type: %s" % "No GeoReferencing Information" )

        self.actionAddLayer.setChecked(False)

#############################End###########################

#printing the layers combined to a pdf
    def onPrint(self):
        filePath = QFileDialog.getSaveFileName(self, "Save File", "", "PDF (*.pdf)")
        fileInfo = QFileInfo(filePath)
        imagePath = fileInfo.absolutePath()
        PrintMapCanvas(self.mapCanvas, self.layer_set, filePath)
    
    def setUpMapsComboBox(self):
        #setting a list of current maps and vector layers in the current directory
        self.maps = glob.glob(self.map_layers + "/*.tif")

        #clear combo box (when map is added//deleted)
        self.mapComboBox.clear()
        
        #checking for current maps and filling mapCombobox with map names
        if len(self.maps) > 0:
            for mapLayer in self.maps:
                #splitting the path name
                mapName = os.path.splitext(os.path.basename(mapLayer))[0]
                self.mapComboBox.addItem(mapName)
                self.mapComboBox.setEnabled(True)
  
    def setMapLayers(self, currentMapLayer, currentVectorDB):
        #layers array for storing rastermap and vector layer
        layers = []
        # Setup the area vector layer.
        uri = QgsDataSourceURI()
        uri.setDatabase(os.path.join(self.cur_dir, "geoData", currentVectorDB + ".sqlite"))
        uri.setDataSource("", currentVectorDB, "GEOMETRY")
        
        #using the QgsRasterLayer QgsVectorLayer class from the pyqgis core package, add to map registry
        self.deforestObjectLayer = QgsVectorLayer(uri.uri(), currentVectorDB, "spatialite")
        QgsMapLayerRegistry.instance().addMapLayer(self.deforestObjectLayer)
        
        self.rasterLayer = QgsRasterLayer(currentMapLayer, currentVectorDB)
        QgsMapLayerRegistry.instance().addMapLayer(self.rasterLayer)
 
        #Append layers list in correct positioning to process for display
        layers.append(QgsMapCanvasLayer(self.deforestObjectLayer))
        layers.append(QgsMapCanvasLayer(self.rasterLayer))
        
        #setting the layerset array to the current id's of the raster and vector layer
        self.layer_set.append(self.deforestObjectLayer.id())
        self.layer_set.append(self.rasterLayer.id())
        
        #Add all the layers to the map canvas.
        self.mapCanvas.setLayerSet(layers)
        self.mapCanvas.setExtent(self.rasterLayer.extent())


    #setting up the data base for the vector layer source
    def setUpDatabase(self, vectorName):
        #getting data base
        db_name = os.path.join(self.cur_dir, "geoData", vectorName + ".sqlite")
        
        #set up data base if one doesnt exist, making use of the class QgsFields create fields for the database
        if not os.path.exists(db_name):
            fields = QgsFields()
            fields.append(QgsField("name", QVariant.String))
            fields.append(QgsField("type", QVariant.String))
            fields.append(QgsField("defType", QVariant.String))
            fields.append(QgsField("date", QVariant.String))
            fields.append(QgsField("area", QVariant.Double))
            
            #the crs used is the same in which the raster layer is reprojected too
            crs = QgsCoordinateReferenceSystem(4326, QgsCoordinateReferenceSystem.EpsgCrsId)
            
            # specific vector layer type WKBPolygon. Vector layer has to given a spefific type of geometry will be utiliased via the data base
            writer = QgsVectorFileWriter(db_name, "utf-8", fields, QGis.WKBPolygon, crs, "SQLite", ["SPATIALITE=YES"])
            
            if writer.hasError() != QgsVectorFileWriter.NoError:
                print "Error creating tracks database!"
            del writer

    # Setup the renderer for the vector layer.
    def setVectorRenderer(self):
        #for type of forest area
        areaColour = ""
        #for cause of deforestation
        areaFill = ""
        #clearing rule in the rule based renderer
        root_rule = QgsRuleBasedRendererV2.Rule(None)
        #looping through to get all the combinations of forest and deforesttaion types
        for area_type in (AREA_TYPE_DEFORESTED, AREA_TYPE_VUN, AREA_TYPE_REFORESTED):
            #setting repective colours depending on forest types
            if area_type == AREA_TYPE_DEFORESTED:
                areaColour = DEF_COLOUR
            elif area_type == AREA_TYPE_VUN:
                areaColour = VUN_COLOUR
            elif area_type == AREA_TYPE_REFORESTED:
                areaColour = REF_COLOUR
                #setting colours for the pattern fill for the types of deforestation
            for def_type in (DEF_TYPE_DEFORESTATION, DEF_TYPE_FORESTFRAGMENTATION, DEF_TYPE_FORESTDEGRADATION):
                if def_type == DEF_TYPE_DEFORESTATION:
                    areaFill = DEFF_COLOUR
                if def_type == DEF_TYPE_FORESTFRAGMENTATION:
                    areaFill = FRAG_COLOUR
                if def_type == DEF_TYPE_FORESTDEGRADATION:
                    areaFill = DEG_COLOUR
                #create symbol
                areaFeatureSymbol = self.createAreaSymbol(areaColour, areaFill)
                #set filter for the rule based renderer
                areaExpression = ("(type='%s') and " + "(defType='%s')") % (area_type, def_type)
                areaDisplayRule = QgsRuleBasedRendererV2.Rule(areaFeatureSymbol, filterExp=areaExpression)
                #adding set symbol design to the renderer root renderer
                root_rule.appendChild(areaDisplayRule)
                    
        #creating the QgsRuleBasedRendererV2 object and setting the rule
        renderer = QgsRuleBasedRendererV2(root_rule)
        #setting the vector layer renderer
        self.deforestObjectLayer.setRendererV2(renderer)

#creating and setting the smybol colours
    def createAreaSymbol(self, areaColour, areaFill):
    
        #creating fill symbol object
        areaFeatureSymbol = QgsFillSymbolV2()
        areaFeatureSymbol.deleteSymbolLayer(0)
    
        #the outline for the type of forest
        areaOutlineSymbol = QgsSimpleFillSymbolLayerV2()
        areaOutlineSymbol .setFillColor(QColor(0, 0, 0, 0))
        areaOutlineSymbol .setBorderColor(QColor(areaColour))
        areaOutlineSymbol .setBorderWidth(0.9)
        areaFeatureSymbol.appendSymbolLayer(areaOutlineSymbol )
        
        #line pattern fill for deforestation type
        areaPatternSymbol = QgsLinePatternFillSymbolLayer()
        areaPatternSymbol.setColor(QColor(areaFill))
        areaPatternSymbol.setLineWidth(2)
        areaPatternSymbol.setDistance(6)
        areaPatternSymbol.setLineAngle(40)
        areaFeatureSymbol.appendSymbolLayer(areaPatternSymbol)
        
        return areaFeatureSymbol

    #initialing and linking the map tool objects: PanTool, AddDeforestObject, RemoveDeforestObject, EditDeforestObject, GetAreaInfoTool classes from mapTools.py to the GUI button actions
    def setMapTools(self):
        
        self.panTool = PanTool(self.mapCanvas)
        self.panTool.setAction(self.actionPanMode)
        
        self.addDeforestObject = AddDeforestObject(self.mapCanvas, self.deforestObjectLayer, self.onDeforestObjectAdded)
        self.addDeforestObject.setAction(self.actionAddArea)
        
        self.removeDeforestObject = RemoveDeforestObject(self.mapCanvas, self.deforestObjectLayer, self.onDeforestObjectRemoved)
        self.removeDeforestObject.setAction(self.actionRemoveArea)
        
        self.editDeforestObject = EditDeforestObject(self.mapCanvas, self.deforestObjectLayer, self.onDeforestObjectEdited)
        self.editDeforestObject.setAction(self.actionEditArea)
        
        self.getAreaInfoTool = GetAreaInfoTool(self.mapCanvas, self.deforestObjectLayer, self.onGetAreaInfo)
        self.getAreaInfoTool.setAction(self.actionGetAreaInfo)


class ReprojectGeospatialFile(QObject):
    
    #Reprojection on the added image
    def reprojectTifFile(self, projectedMap, fileName, onAddedLayer):
        
        #Open .tif - gdal will automatically assign correct driver: raster format
        src_ds = gdal.Open(fileName)
        
        #if geoReferencing information is not contained projection will fail
        try:
            #Create the final warped image
            gdal.Warp(projectedMap ,src_ds, dstSRS='EPSG:4326')
        except:
            onAddedLayer("","")
        #on success of the warp send path and name of for the raster layer
        else:
            onAddedLayer(projectedMap)

class PrintMapCanvas(QObject):
    
    def __init__(self, mapCanvas, layer_set, imageName):
    
        comp, mapSettings = self.create_composition(layer_set, mapCanvas.extent())
        
        #set sytle for printering map
        comp.setPlotStyle(QgsComposition.Print)
        
        #using pyqgis map composer class
        composerMap = QgsComposerMap(comp, 5,5,200,200)
        
        #Uses mapsettings value
        composerMap.setNewExtent(mapSettings.extent())
        
        comp.addItem(composerMap)
        #use QPrinter to print the file for map to be printed on
        printer = QPrinter()
        #set format
        printer.setOutputFormat(QPrinter.PdfFormat)
        #set location of output
        printer.setOutputFileName(imageName)
        #setting size, colour and print seolution of the image
        printer.setPaperSize(QSizeF(comp.paperWidth(), comp.paperHeight()),    QPrinter.Millimeter)
        printer.setFullPage(True)
        printer.setColorMode(QPrinter.Color)
        printer.setResolution(comp.printResolution())
        
        #set object painter with the set out size
        pdfPainter = QPainter(printer)
        
        paperRectMM = printer.pageRect(QPrinter.Millimeter)
        paperRectPixel = printer.pageRect(QPrinter.DevicePixel)
        comp.render(pdfPainter, paperRectPixel, paperRectMM)
        pdfPainter.end()
    
    def create_composition(self, layer_list, extent):
        
        #set the compition extent to that of the current extent of the map canvas
        mapSettings = QgsMapSettings()
        mapSettings.setLayers(layer_list)
        mapSettings.setExtent(extent)
        comp = QgsComposition(mapSettings)
        #return map settings and composition for printing
        return comp, mapSettings


def main():
    
    #instance of qt application
    app = QApplication(sys.argv)
    # supply path to qgis install location where the resources are stored
    # setting the second argument to True enables the GUI
    QgsApplication.setPrefixPath(os.environ['QGIS_PREFIX'], True) #initialising the pyQgis environment
    # This line is providing a path to Qt telling it to look here for plugins
    # load providers
    QgsApplication.initQgis()
    
    #creating instance of the class, this sets up the main window, contains the map canvas and contains the event handlers.
    
    deforestMapWindow = DeforestationMapWindow()
    deforestMapWindow.show()
    deforestMapWindow.raise_()
    
    #filling the current map combo box
    deforestMapWindow.setUpMapsComboBox()
    deforestMapWindow.setButtonsStatus()
    #executing Qt application until user quites
    app.exec_()
    
    deforestMapWindow.close()
    #removes the provider and layer registries from memory
    QgsApplication.exitQgis()
    #issues when deleting an object
    app.deleteLater()

if __name__ == "__main__":
    main()



----------map tools------------

#importing the various libraries needed
from qgis.core import *
from qgis.gui import *
from PyQt4.QtCore import *
from PyQt4.QtGui import *
from constants import *
import sys
import os
import math

#special mixin class with helper methods for deforestation custom maps tools
class CustomMapToolMixin:
    
    #set reference to current layer for use on custom map tools
    def setCurrentLayer(self, currentLayer):
        self.currentLayer = currentLayer
    
    #converts current mouse position and(pixel coordinates) of the screen into the map and layer coordinate system and transforms
    def convertCoordinates(self, screenPoint):
        return (self.toMapCoordinates(screenPoint), self.toLayerCoordinates(self.currentLayer, screenPoint))

    #calculate the tolerance for allowing minor error margin for when the user clicks on the map canvas, 5 screen pixels apart.
    def calcTol(self, position):
        point1 = QPoint(position.x(), position.y())
        point2 = QPoint(position.x() + 5, position.y())
        
        mapPoint1,layerPoint1 = self.convertCoordinates(point1)
        mapPoint2,layerPoint2 = self.convertCoordinates(point2)
        tolerance = layerPoint2.x() - layerPoint1.x()
        
        return tolerance

#find the selected feaeture
    def findFeatureAt(self, position):
        mapPoint,layerPoint = self.convertCoordinates(position)
        tolerance = self.calcTol(position)
        
        #checking in the created tolerance grid
        toleranceRect = QgsRectangle(layerPoint.x() - tolerance,
                                  layerPoint.y() - tolerance,
                                  layerPoint.x() + tolerance,
                                  layerPoint.y() + tolerance)
                                  
        #find first deforestation area feature in rectangle
        request = QgsFeatureRequest()
        request.setFilterRect(toleranceRect)
        request.setFlags(QgsFeatureRequest.ExactIntersect)
            
        for feature in self.currentLayer.getFeatures(request):
            return feature
            
        return None
    
#finds area feature's closest vertex to the click point of the user
    def findVertexAt(self, feature, position):
        
        mapPoint,layerPoint = self.convertCoordinates(position)
        tolerance     = self.calcTol(position)
        
        #calculate the closet feature to the click point using the area features geometry closetvertex
        vertexCoord,vertex,prevVertex,nextVertex,vertexDifference = \
            feature.geometry().closestVertex(layerPoint)

        vertexDifference = math.sqrt(vertexDifference)
        
        #checking area feature within tolerance
        if vertexDifference > tolerance:
            return None
        else:
            return vertex

#The subclasses of maptool

#inherits from QgqMapTool and directly manipulates the map canvas
class PanTool(QgsMapTool):
    
    #initialise the map tool and set tool to use a cross qt hand cursor
    def __init__(self, canvas):
        QgsMapTool.__init__(self, canvas)
        self.setCursor(Qt.OpenHandCursor)
        self.dragging = False
    
    #respond to the canvas event
    def canvasMoveEvent(self, event):
        if event.buttons() == Qt.LeftButton:
            self.dragging = True
            self.canvas().panAction(event)

    #respond when the user releases the mouse
    def canvasReleaseEvent(self, event):
        if event.button() == Qt.LeftButton and self.dragging:
            self.canvas().panActionEnd(event.pos())
            self.dragging = False

#adding of a deforestation area feature
class AddDeforestObject(QgsMapTool, CustomMapToolMixin):
    
    #initisaling the map canvas, current layer, and finish call function
    def __init__(self, canvas, currentLayer, onDeforestObjectAdded):
        
        QgsMapTool.__init__(self, canvas)
        self.canvas = canvas
        self.onDeforestObjectAdded = onDeforestObjectAdded
        #canvas rubberBand to visualize drawing of area
        self.rubberBand = None
        self.tempRubberBand = None
        
        #array to capture the points
        self.recordedPoints = []
        
        #bool representing capturing mode
        self.recording = False
        
        #set the current vector layer
        self.setCurrentLayer(currentLayer)
        self.setCursor(Qt.CrossCursor)
    
    #check user type of click to respond repectively
    def canvasReleaseEvent(self, event):
        #left click start capturing the points
        if event.button() == Qt.LeftButton:
            #check whether in recording mode
            if not self.recording:
                self.startRecording()
            #add users selected point
            self.addAreaPoint(event.pos())
        #stop caturing and get the captured area points
        elif event.button() == Qt.RightButton:
            #gets recorded users selected points
            points = self.getRecordedPoints()
            #stop recording
            self.stopRecording()
            #check to see if user captured any points
            if points != None:
                self.pointsRecorded(points)

    #responds to whenever user moves mouse, updates the tempRubberband to display the polygon to the moved position
    def canvasMoveEvent(self, event):
        if self.tempRubberBand != None and self.recording:
            mapPoint,layerPt = self.convertCoordinates(event.pos())
            self.tempRubberBand.movePoint(mapPoint)

    #catching key press event
    def keyPressEvent(self, event):
        #pyQGIS by default uses back space and delete key to delete the currently selected feature, event dot ignore
        #checking if user pressed repective button
        if event.key() == Qt.Key_Backspace or event.key() == Qt.Key_Delete:
            #delete last vertex of the recorded polygon
            self.deleteAreaPoint()
            event.ignore()

#starting capturing the users selected area points
    def startRecording(self):
        color = QColor("red")
        color.setAlphaF(0.78)
        
        #rubberBand is set up (width and colour to the canvas and the geometry type: polygon)
        self.rubberBand = QgsRubberBand(self.canvas, QGis.Polygon)
        self.rubberBand.setWidth(2)
        self.rubberBand.setColor(color)
        self.rubberBand.show()
        
        #tempRubberBand is set up, displays a dotted line when user is setting more than one point
        self.tempRubberBand = QgsRubberBand(self.canvas, QGis.Polygon)
        self.tempRubberBand.setWidth(2)
        self.tempRubberBand.setColor(color)
        self.tempRubberBand.setLineStyle(Qt.DotLine)
        self.tempRubberBand.show()
        
        #current capturing
        self.recording = True

#when user stops drawing the polygon
    def stopRecording(self):
        
        if self.rubberBand != None:
            self.canvas.scene().removeItem(self.rubberBand)
            self.rubberBand = None
        
        if self.tempRubberBand != None:
            self.canvas.scene().removeItem(self.tempRubberBand)
            self.tempRubberBand = None
        
        #reset variables
        self.recording = False
        self.recordedPoints = []
        self.canvas.refresh()

#adds the users clicked point
    def addAreaPoint(self, canvasPoint):
        #retrives map and layer coordinates of the users click
        mapPoint, layerPoint = self.convertCoordinates(canvasPoint)
        #adds the map layer coordinate to the rubberpant, records the currenlt captured geometry layer coordinate
        self.rubberBand.addPoint(mapPoint)
        
        self.recordedPoints.append(layerPoint)
        
        #resets the temp rubber band
        self.tempRubberBand.reset(QGis.Polygon)
        
        #set the start point of the currently recorded geometry
        startPoint = self.rubberBand.getPoint(0, 0)
        
        #update the tempRubberBand
        self.tempRubberBand.addPoint(startPoint)
        self.tempRubberBand.movePoint(mapPoint)
        self.tempRubberBand.addPoint(mapPoint)
   
   #delete the previous add area point
    def deleteAreaPoint(self):
        
        if not self.recording:
            return
        #getting the amount of vertices captured by both rubber boths
        numAreaPoints = self.rubberBand.numberOfVertices()
        tempAreaPoints = self.tempRubberBand.numberOfVertices()
        numberPoints = len(self.recordedPoints)
        
        #return if not enough points are recorded
        if numAreaPoints < 1 or numberPoints < 1:
            return
        #remove point from rubberband
        self.rubberBand.removePoint(-1)
        #moves point of tempRubberBand to the point before the last removed point.
        if numAreaPoints > 1:
            if tempAreaPoints > 1:
                point = self.rubberBand.getPoint(0, numAreaPoints-2)
                self.tempRubberBand.movePoint(tempAreaPoints-2, point)
        else:
            self.tempRubberBand.reset(QGis.Polygon)
        #delete from recorded point from list
        del self.recordedPoints[-1]

#gets the recorded area points, checks whether user added enough
    def getRecordedPoints(self):
        pointsCoordinates = self.recordedPoints
        if len(pointsCoordinates) < 3:
            return None
        else:
            #close polygon
            pointsCoordinates.append(pointsCoordinates[0])
        return pointsCoordinates
            
    #finished recording polygon
    def pointsRecorded(self, newPolygon):
        #data provider for the vector layer to store the polygon
        fields = self.currentLayer.dataProvider().fields()
        #create geomtry type polygon and pass recorded polygon
        geometry = QgsGeometry.fromPolygon([newPolygon])
        #calculate are for polygon
        area = self.calculateArea(newPolygon)
        #create new QgsFeature object
        feature = QgsFeature()
        #set the geomtetry
        feature.setGeometry(geometry)
        feature.setFields(fields)
    
        #set default attributes for the feature
        feature.setAttribute("name", "New Area")
        feature.setAttribute("type", AREA_TYPE_DEFORESTED)
        feature.setAttribute("defType", DEF_TYPE_DEFORESTATION)
        feature.setAttribute("date", "default")
        feature.setAttribute("area", area)
        
        #add new deforestation feature to the area
        self.currentLayer.addFeature(feature)
        self.currentLayer.updateExtents()
        #trigger repaint of the
        self.currentLayer.triggerRepaint()
        #call back function
        self.onDeforestObjectAdded()

#using the PyQGIS geospatial analysis class
    def calculateArea(self, polygon):
        #set up the area calculator class
        calculator = QgsDistanceArea()
        #set the ellipsoid to the coordinate reference of the vector layer
        calculator.setEllipsoid('WGS84')
        calculator.setEllipsoidalMode(True)
            #are in squared kilometers
        calculator.computeAreaInit()
        area = calculator.measurePolygon(polygon)
        round(area, 2)
        return area


#removing selected deforestation area feature by id from vector layer
class RemoveDeforestObject(QgsMapTool, CustomMapToolMixin):
    #set variables for areaFeatureId, call back function, current layer and cursor type
    def __init__(self, canvas, currentLayer, onDeforestObjectRemoved):
        QgsMapTool.__init__(self, canvas)
        self.onDeforestObjectRemoved = onDeforestObjectRemoved
        self.areaFeatureId = None
        self.setCurrentLayer(currentLayer)
        self.setCursor(Qt.CrossCursor)
   
   #getting the users selected feature via findFeatureAt
   
    def canvasPressEvent(self, event):
        areaFeature = self.findFeatureAt(event.pos())
        if areaFeature != None:
            #get id for deletion
            self.areaFeatureId = areaFeature.id()
        else:
            self.areaFeatureId  = None

    #delete on release of mouse
    def canvasReleaseEvent(self, event):
        areaFeature = self.findFeatureAt(event.pos())
        if areaFeature != None and areaFeature.id() == self.areaFeatureId:
            self.currentLayer.deleteFeature(areaFeature.id())
            self.onDeforestObjectRemoved()

#the user edting a currernt deforestation area geometry
class EditDeforestObject(QgsMapTool, CustomMapToolMixin):
    #intialising call back funtion, feature, point and reference to canvas.
    #to keep track of the user dragging the bool variable is used
    def __init__(self, canvas, currentLayer, onDeforestObjectEdited):
        QgsMapTool.__init__(self, canvas)
        self.onDeforestObjectEdited = onDeforestObjectEdited
        self.dragging = False
        self.feature = None
        self.areaVertex = None
        #setting the current layer and cursor type
        self.setCurrentLayer(currentLayer)
        self.setCursor(Qt.CrossCursor)
    
    #check the user moving, pressing and releasing the mouse of the map canvas
    
    #check for when user clicks on map canvas
    def canvasPressEvent(self, event):
        
        #find clicked on derforestation feature and vertex of that feature with the use of the helper methods inherited
        feature = self.findFeatureAt(event.pos())
        if feature == None:
            return
        areaVertex = self.findVertexAt(feature, event.pos())
        if areaVertex == None:
            return
        
        # if the user left click move point of set deforestation area feature, setting dragging to true so dont edit non selected area feature
        if event.button() == Qt.LeftButton:
            self.dragging = True
            self.feature = feature
            self.areaVertex = areaVertex
            self.newVertex(event.pos())
            self.canvas().refresh()

    #check if user editing area and set edited geomtry
    def canvasMoveEvent(self, event):
        if self.dragging:
            #replace geomtry
            self.newVertex(event.pos())
            self.canvas().refresh()

    #set new geometry of the deforestation area when user releases
    def canvasReleaseEvent(self, event):
        if self.dragging:
            self.newVertex(event.pos())
            self.currentLayer.updateExtents()
            self.canvas().refresh()
            self.dragging = False
            self.feature = None
            self.areaVertex = None

    #sets new point of users mouse position when click on a feature
    def newVertex(self, position):
        #seet geometry type
        geometry = self.feature.geometry()
        #get layer coordinates of mouse
        layerPoint = self.toLayerCoordinates(self.currentLayer, position)
        #move selected point for editing
        geometry.moveVertex(layerPoint.x(), layerPoint.y(), self.areaVertex)
        #update the deforesation area feature to new position
        self.currentLayer.changeGeometry(self.feature.id(), geometry)
        #call back function
        self.onDeforestObjectEdited()

#selecting the deforestation area feature for viewing of attributes
class GetAreaInfoTool(QgsMapTool, CustomMapToolMixin):
    #set the current vector layer and call back function
    def __init__(self, canvas, currentLayer, onGetAreaInfo):
        QgsMapTool.__init__(self, canvas)
        self.onGetAreaInfo = onGetAreaInfo
        self.setCurrentLayer(currentLayer)
        self.setCursor(Qt.WhatsThisCursor)
    
    #simple using findfeature at to get the users selected deforestation are image
    def canvasReleaseEvent(self, event):
        if event.button() != Qt.LeftButton: return
        feature = self.findFeatureAt(event.pos())
        if feature != None:
            self.onGetAreaInfo(feature)


-----------------dialog tools---------

from PyQt4.QtCore import *
from PyQt4.QtGui import *
from qgis.core import *
from qgis.gui import *

import os
from constants import *

#Dialog for displaying the map information
class MapDialog(QDialog):
    #Class initializer
    def __init__(self, parent, currentMapVectorLayer):
        QDialog.__init__(self, parent)
        self.setWindowTitle("Deforestation Analysis")
        
        #setting the passed vector layer
        self.currentMap = currentMapVectorLayer
        self.request = QgsFeatureRequest()
        self.mapNames = []
        self.amountOfAreas = 0
        
        #getting list of the current features names for combobox
        for feature in self.currentMap.getFeatures():
            self.mapNames.append(str(feature.attribute("name")))
            self.amountOfAreas = self.amountOfAreas +1
       
       #setting data for combobox
        self.forestTypes = [AREA_TYPE_DEFORESTED, AREA_TYPE_VUN, AREA_TYPE_REFORESTED]

        self.defTypes = [DEF_TYPE_DEFORESTATION, DEF_TYPE_FORESTDEGRADATION , DEF_TYPE_FORESTFRAGMENTATION ]

        #ComboBox by Features
        self.nameField = QComboBox(self)
        if len(self.mapNames) > 0:
            self.nameField.addItems(self.mapNames)
        #ComboBox by forest type
        self.forestTypeField = QComboBox(self)
        self.forestTypeField.addItems(self.forestTypes)
        
        #ComboBox by deforestation type
        self.defTypeField = QComboBox(self)
        self.defTypeField.addItems(self.defTypes)
        
        #connect methods to combo changed index method
        self.nameField.currentIndexChanged.connect(self.onNameChange)
        self.forestTypeField.currentIndexChanged.connect(self.onForestTypeChange)
        self.defTypeField.currentIndexChanged.connect(self.onDefTypeChange)
        
        #setting labels for area totals
        self.amountAreasField = QLabel(self)
        self.areaTotalField = QLabel(self)
        self.areaTypeTotalField = QLabel(self)
        self.areaDefTypeTotalField = QLabel(self)
        self.form = QFormLayout()
        
        #setting vertical layout
        self.form.addRow("Name", self.nameField, )
        self.form.addRow("Area", self.areaTotalField)
        self.form.addRow("Type", self.forestTypeField)
        self.form.addRow("Total area covered:", self.areaTypeTotalField)
        self.form.addRow("Deforestion Type", self.defTypeField)
        self.form.addRow("Total area covered:", self.areaDefTypeTotalField)
        self.form.addRow("Total amount of features: ", self.amountAreasField)
        
        self.cancelButton = QPushButton("Close", self)
        self.connect(self.cancelButton, SIGNAL("clicked()"), self.reject)
        
        #setting layour of buttons
        self.button = QHBoxLayout()
        self.button.addStretch(1)
        self.button.addWidget(self.cancelButton)
        
        self.layout = QVBoxLayout(self)
        self.layout.addLayout(self.form)
        self.layout.addSpacing(5)
        self.layout.addLayout(self.button)
        
        self.setLayout(self.layout)
        self.resize(self.sizeHint())

        #setting the label to display the amount of features in the layer
        self.amountAreasField.setText(str(self.amountOfAreas))
        
        self.onNameChange()
        self.onForestTypeChange()
        self.onDefTypeChange()
    
    #calculating area for single area
    def onNameChange(self):
        area = 0
        index = self.nameField.currentIndex()
        for feature in self.currentMap.getFeatures():
            if index == feature.id():
                area = feature.attribute("area")
                self.areaTotalField.setText(str(area))

    # Calculating total area for features of that forest type
    def onForestTypeChange(self):
        curText = str(self.forestTypeField.currentText())
        #expression to filter get features by type
        expr = QgsExpression(" \"type\" = '{}'".format(curText))
        areaTotal = 0
        for feature in self.currentMap.getFeatures(QgsFeatureRequest(expr)):
            areaTotal += float(feature.attribute("area"))
        self.areaTypeTotalField.setText(str(areaTotal))

    #setting total area to for features of that deforestation type
    def onDefTypeChange(self):
        curText = str(self.defTypeField.currentText())
        expr = QgsExpression(" \"defType\" = '{}'".format(curText))
        areaTotal = 0
        for feature in self.currentMap.getFeatures(QgsFeatureRequest(expr)):
            areaTotal += float(feature.attribute("area"))
        self.areaDefTypeTotalField.setText(str(areaTotal))

#selected features, from getAreaInfo map tool

class getAreaInfoDialog(QDialog):
    def __init__(self, parent, feature):
        QDialog.__init__(self, parent)
        self.setWindowTitle("Area Info")
        
        #setting the combo box by forest type
        self.types = [AREA_TYPE_DEFORESTED, AREA_TYPE_VUN, AREA_TYPE_REFORESTED]
        
        #setting the combo box by def type
        self.defTypes = [DEF_TYPE_DEFORESTATION, DEF_TYPE_FORESTDEGRADATION , DEF_TYPE_FORESTFRAGMENTATION ]
      
        #setting editable QLineEdit boxs for the name and date attributes
        self.nameField = QLineEdit(self)
        self.dateField = QLineEdit(self)
        
        #set comboboxes
        self.forestTypeField = QComboBox(self)
        self.forestTypeField.addItems(self.types)
        
        self.defTypeField = QComboBox(self)
        self.defTypeField.addItems(self.defTypes)
       
        self.areaField = QLabel(self)
        
        #adding widgets to the form dialot layout
        self.form = QFormLayout()
        self.form.addRow("Name", self.nameField)
        self.form.addRow("Type",      self.forestTypeField)
        self.form.addRow("Deforestion Type",      self.defTypeField)
        self.form.addRow("Date",      self.dateField)
        self.form.addRow("Area",      self.areaField)
        
        #setting up the buttons
        self.okButton = QPushButton("OK", self)
        self.connect(self.okButton, SIGNAL("clicked()"), self.accept)
        
        self.cancelButton = QPushButton("Cancel", self)
        self.connect(self.cancelButton, SIGNAL("clicked()"), self.reject)
        
        #setting layout for the buttons
        self.buttons = QHBoxLayout()
        self.buttons.addStretch(1)
        self.buttons.addWidget(self.okButton)
        self.buttons.addWidget(self.cancelButton)
        
        self.layout = QVBoxLayout(self)
        self.layout.addLayout(self.form)
        self.layout.addSpacing(10)
        self.layout.addLayout(self.buttons)
        
        self.setLayout(self.layout)
        self.resize(self.sizeHint())

    #load the selected area features attributes into and set the current display of the dialog box to reflect features attributes
    def loadAttributes(self, feature):
        nameAttr = feature.attribute("name")
        forestTypeAttr = feature.attribute("type")
        defTypeAttr = feature.attribute("defType")
        dateAttr = feature.attribute("date")
        areaAttr = feature.attribute("area")
    
    #set combo box to features current forest and deforestation types
        if   forestTypeAttr == AREA_TYPE_DEFORESTED : index = 0
        elif forestTypeAttr == AREA_TYPE_VUN : index = 1
        elif forestTypeAttr == AREA_TYPE_REFORESTED : index = 2
        else : index = 0
        
        self.forestTypeField.setCurrentIndex(index)
        
        if   defTypeAttr == DEF_TYPE_DEFORESTATION : index = 0
        elif defTypeAttr == DEF_TYPE_FORESTDEGRADATION : index = 1
        elif defTypeAttr == DEF_TYPE_FORESTFRAGMENTATION : index = 2
        else : index = 0
        
        self.defTypeField.setCurrentIndex(index)
        
        self.areaField.setText(str(areaAttr))
        
        #validation statements
        if dateAttr != None:
            self.dateField.setText(dateAttr)
        else:
            self.dateField.setText("")
        if nameAttr != None:
            self.nameField.setText(nameAttr)
        else:
            self.nameField.setText("")
    
    #save the current set of attributes in the fields and comboboxes to the area feature
    def saveAttributes(self, feature):
        
        index = self.forestTypeField.currentIndex()
        if   index == 0: forestTypeAttr = AREA_TYPE_DEFORESTED
        elif index == 1: forestTypeAttr = AREA_TYPE_VUN
        elif index == 2: forestTypeAttr = AREA_TYPE_REFORESTED
        
        dateAttr = str(self.dateField.text())
        nameAttr = str(self.nameField.text())
        
        index = self.defTypeField.currentIndex()
        if   index == 0: defTypeAttr = DEF_TYPE_DEFORESTATION
        elif index == 1: defTypeAttr = DEF_TYPE_FORESTDEGRADATION
        elif index == 2: defTypeAttr = DEF_TYPE_FORESTFRAGMENTATION
       
        feature.setAttribute("name", nameAttr)
        feature.setAttribute("type", forestTypeAttr)
        feature.setAttribute("defType", defTypeAttr)
        feature.setAttribute("date", dateAttr)


--------main ui window---------


#Access to Qt library
from PyQt4.QtCore import *
from PyQt4.QtGui import *

#importing the images for the buttons
import resources

class Ui_MainWindow(object):
    
    #passed in deforestationWindow
    def setupUi(self, window):
        
        window.setWindowTitle("Deforestation Monitoring Application")

        #creating a central widget to hold map canvas
        self.centralWidget = QWidget(window)
        self.centralWidget.setMinimumSize(900, 500)
        window.setCentralWidget(self.centralWidget)
      
        #setiing combo box for the maps
        self.mapComboBox = QComboBox(window)
        self.mapComboBox.setEnabled(False)
        
        #setting the tool bar object and a child of QMainWindow
        self.toolbar = QToolBar(window)
        
        #adding to the tool bar to the window
        window.addToolBar(Qt.TopToolBarArea, self.toolbar)
        
        #add options to the menu bar
        self.menuBar = window.menuBar()
        self.fileMenu = self.menuBar.addMenu("File")
        self.mapMenu = self.menuBar.addMenu("Map")
        
        #creating QAction objects
        
        #buttons set to checkable, setting image of the button to the compiled png image.
        
        self.actionPrint = QAction("Print Map: PDF", window)
        
        buttonIcon = QIcon(":/resources/zoomIn.png")
        self.actionZoomIn = QAction(buttonIcon, "Zoom In", window)
        self.actionZoomIn.setShortcut(QKeySequence.ZoomIn)

        buttonIcon = QIcon(":/resources/zoomOut.png")
        self.actionZoomOut = QAction(buttonIcon, "Zoom Out", window)
        self.actionZoomOut.setShortcut(QKeySequence.ZoomOut)

        buttonIcon = QIcon(":/resources/panMode.png")
        self.actionPanMode = QAction(buttonIcon, "Pan", window)
        self.actionPanMode.setCheckable(True)

        icon = QIcon(":/resources/editMode.png")
        self.actionEditMode = QAction(icon, "Edit", window)
        self.actionEditMode.setCheckable(True)
        
        buttonIcon = QIcon(":/resources/getInfo.png")
        self.actionGetAreaInfo = QAction(buttonIcon, "Get Info", window)
        self.actionGetAreaInfo.setCheckable(True)
        
        buttonIcon = QIcon(":/resources/drawArea.png")
        self.actionAddArea = QAction(buttonIcon, "Draw Area", window)
        self.actionAddArea.setCheckable(True)
        
        buttonIcon = QIcon(":/resources/drawPolygon.png")
        self.actionEditArea = QAction(buttonIcon, "Edit Area", window)
        self.actionEditArea.setCheckable(True)
        
        buttonIcon = QIcon(":/resources/remove.png")
        self.actionRemoveArea = QAction(buttonIcon, "Remove Area", window)
        self.actionRemoveArea.setCheckable(True)
        
        buttonIcon = QIcon(":/resources/addLayer.png")
        self.actionAddLayer = QAction(buttonIcon, "Add Layer", window)
        self.actionAddLayer.setCheckable(True)
        
        buttonIcon = QIcon(":/resources/removeLayer.png")
        self.actionRemoveLayer = QAction(buttonIcon, "Remove Layer", window)
        self.actionRemoveLayer.setCheckable(True)
        
        buttonIcon = QIcon(":/resources/mapInfo.png")
        self.actionMapInfo = QAction(buttonIcon, "Map Info", window)
        self.actionMapInfo.setCheckable(True)
        
        #adding the QAction objects and widgets to the respective bars
        
        self.fileMenu.addAction(self.actionRemoveArea)
        self.fileMenu.addAction(self.actionRemoveLayer)
        
        self.mapMenu.addAction(self.actionPrint)
        self.mapMenu.addAction(self.actionZoomIn)
        self.mapMenu.addAction(self.actionZoomOut)
        self.mapMenu.addAction(self.actionPanMode)
        self.mapMenu.addAction(self.actionEditMode)
        
        #grouping actions with addSeparator
        self.toolbar.addAction(self.actionZoomIn)
        self.toolbar.addAction(self.actionZoomOut)
        self.toolbar.addAction(self.actionPanMode)
        self.toolbar.addAction(self.actionEditMode)
        self.toolbar.addSeparator()
        self.toolbar.addAction(self.actionGetAreaInfo)
        self.toolbar.addAction(self.actionAddArea)
        self.toolbar.addAction(self.actionEditArea)
        self.toolbar.addAction(self.actionRemoveArea)
        self.toolbar.addSeparator()
        self.toolbar.addAction(self.actionAddLayer)
        self.toolbar.addAction(self.actionRemoveLayer)
        self.toolbar.addSeparator()
        self.toolbar.addAction(self.actionMapInfo)
        self.toolbar.addWidget(self.mapComboBox)
        
        #resize to fit new content
        window.resize(window.sizeHint())


-----resource.qrc file------

<RCC>
  <qresource>
    <file>resources/addLayer.png</file>
    <file>resources/removeLayer.png</file>
    <file>resources/zoomIn.png</file>
    <file>resources/zoomOut.png</file>
    <file>resources/panMode.png</file>
    <file>resources/editMode.png</file>
    <file>resources/mapInfo.png</file>
    <file>resources/drawArea.png</file>
    <file>resources/drawPolygon.png</file>
    <file>resources/remove.png</file>
    <file>resources/getInfo.png</file>
  </qresource></RCC>



-----------makefile---------

RESOURCES_FILE = resources.py

default: compile

compile: $(RESOURCES_FILE)

%.py : %.qrc
	export PATH="/Applications/QGIS.app/Contents/MacOS/bin:$PATH"; export PYTHONPATH="/Applications/QGIS.app/Contents/Resources/python"; pyrcc4 -o $@ $<

clean:
	rm *pyc
	rm $(RESOURCES_FILE)



------------script-----------

export PYTHONPATH="$PYTHONPATH:/Applications/QGIS.app/Contents/Resources/python"
export PYTHONPATH="$PYTHONPATH:/Library/Frameworks/GDAL.framework/Versions/2.1/Python/2.7/site-packages"
export QGIS_PREFIX="/Applications/QGIS.app/Contents/Resources"

python deforestationMain.py
